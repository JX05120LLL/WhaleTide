{"ast":null,"code":"function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return r; }; var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = \"function\" == typeof Symbol ? Symbol : {}, i = o.iterator || \"@@iterator\", a = o.asyncIterator || \"@@asyncIterator\", u = o.toStringTag || \"@@toStringTag\"; function c(t, r, e, n) { return Object.defineProperty(t, r, { value: e, enumerable: !n, configurable: !n, writable: !n }); } try { c({}, \"\"); } catch (t) { c = function c(t, r, e) { return t[r] = e; }; } function h(r, e, n, o) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype); return c(a, \"_invoke\", function (r, e, n) { var o = 1; return function (i, a) { if (3 === o) throw Error(\"Generator is already running\"); if (4 === o) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var u = n.delegate; if (u) { var c = d(u, n); if (c) { if (c === f) continue; return c; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (1 === o) throw o = 4, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = 3; var h = s(r, e, n); if (\"normal\" === h.type) { if (o = n.done ? 4 : 2, h.arg === f) continue; return { value: h.arg, done: n.done }; } \"throw\" === h.type && (o = 4, n.method = \"throw\", n.arg = h.arg); } }; }(r, n, new Context(o || [])), !0), a; } function s(t, r, e) { try { return { type: \"normal\", arg: t.call(r, e) }; } catch (t) { return { type: \"throw\", arg: t }; } } r.wrap = h; var f = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var l = {}; c(l, i, function () { return this; }); var p = Object.getPrototypeOf, y = p && p(p(x([]))); y && y !== e && n.call(y, i) && (l = y); var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l); function g(t) { [\"next\", \"throw\", \"return\"].forEach(function (r) { c(t, r, function (t) { return this._invoke(r, t); }); }); } function AsyncIterator(t, r) { function e(o, i, a, u) { var c = s(t[o], t, i); if (\"throw\" !== c.type) { var h = c.arg, f = h.value; return f && \"object\" == _typeof(f) && n.call(f, \"__await\") ? r.resolve(f.__await).then(function (t) { e(\"next\", t, a, u); }, function (t) { e(\"throw\", t, a, u); }) : r.resolve(f).then(function (t) { h.value = t, a(h); }, function (t) { return e(\"throw\", t, a, u); }); } u(c.arg); } var o; c(this, \"_invoke\", function (t, n) { function i() { return new r(function (r, o) { e(t, n, r, o); }); } return o = o ? o.then(i, i) : i(); }, !0); } function d(r, e) { var n = e.method, o = r.i[n]; if (o === t) return e.delegate = null, \"throw\" === n && r.i[\"return\"] && (e.method = \"return\", e.arg = t, d(r, e), \"throw\" === e.method) || \"return\" !== n && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), f; var i = s(o, r.i, e.arg); if (\"throw\" === i.type) return e.method = \"throw\", e.arg = i.arg, e.delegate = null, f; var a = i.arg; return a ? a.done ? (e[r.r] = a.value, e.next = r.n, \"return\" !== e.method && (e.method = \"next\", e.arg = t), e.delegate = null, f) : a : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, f); } function w(t) { this.tryEntries.push(t); } function m(r) { var e = r[4] || {}; e.type = \"normal\", e.arg = t, r[4] = e; } function Context(t) { this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0); } function x(r) { if (null != r) { var e = r[i]; if (e) return e.call(r); if (\"function\" == typeof r.next) return r; if (!isNaN(r.length)) { var o = -1, a = function e() { for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(_typeof(r) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, \"constructor\", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), r.isGeneratorFunction = function (t) { var r = \"function\" == typeof t && t.constructor; return !!r && (r === GeneratorFunction || \"GeneratorFunction\" === (r.displayName || r.name)); }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, \"GeneratorFunction\")), t.prototype = Object.create(v), t; }, r.awrap = function (t) { return { __await: t }; }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () { return this; }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(h(t, e, n, o), i); return r.isGeneratorFunction(e) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, g(v), c(v, u, \"Generator\"), c(v, i, function () { return this; }), c(v, \"toString\", function () { return \"[object Generator]\"; }), r.keys = function (t) { var r = Object(t), e = []; for (var n in r) e.unshift(n); return function t() { for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t; return t.done = !0, t; }; }, r.values = x, Context.prototype = { constructor: Context, reset: function reset(r) { if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) \"t\" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0][4]; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(r) { if (this.done) throw r; var e = this; function n(t) { a.type = \"throw\", a.arg = r, e.next = t; } for (var o = e.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i[4], u = this.prev, c = i[1], h = i[2]; if (-1 === i[0]) return n(\"end\"), !1; if (!c && !h) throw Error(\"try statement without catch or finally\"); if (null != i[0] && i[0] <= u) { if (u < c) return this.method = \"next\", this.arg = t, n(c), !0; if (u < h) return n(h), !1; } } }, abrupt: function abrupt(t, r) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) { var o = n; break; } } o && (\"break\" === t || \"continue\" === t) && o[0] <= r && r <= o[2] && (o = null); var i = o ? o[4] : {}; return i.type = t, i.arg = r, o ? (this.method = \"next\", this.next = o[2], f) : this.complete(i); }, complete: function complete(t, r) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && r && (this.next = r), f; }, finish: function finish(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[2] === t) return this.complete(e[4], e[3]), m(e), f; } }, \"catch\": function _catch(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[0] === t) { var n = e[4]; if (\"throw\" === n.type) { var o = n.arg; m(e); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(r, e, n) { return this.delegate = { i: x(r), r: e, n: n }, \"next\" === this.method && (this.arg = t), f; } }, r; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nimport { ref, onMounted, watch, onBeforeUnmount, computed, unref, watchEffect } from 'vue';\nimport { offset, flip, shift, detectOverflow, arrow, computePosition, autoUpdate } from '@floating-ui/dom';\nimport { isArray, isString, isFunction } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\nimport { keysOf } from '../../../utils/objects.mjs';\nvar useTarget = function useTarget(target, open, gap, mergedMask, scrollIntoViewOptions) {\n  var posInfo = ref(null);\n  var getTargetEl = function getTargetEl() {\n    var targetEl;\n    if (isString(target.value)) {\n      targetEl = document.querySelector(target.value);\n    } else if (isFunction(target.value)) {\n      targetEl = target.value();\n    } else {\n      targetEl = target.value;\n    }\n    return targetEl;\n  };\n  var updatePosInfo = function updatePosInfo() {\n    var targetEl = getTargetEl();\n    if (!targetEl || !open.value) {\n      posInfo.value = null;\n      return;\n    }\n    if (!isInViewPort(targetEl)) {\n      targetEl.scrollIntoView(scrollIntoViewOptions.value);\n    }\n    var _targetEl$getBounding = targetEl.getBoundingClientRect(),\n      left = _targetEl$getBounding.left,\n      top = _targetEl$getBounding.top,\n      width = _targetEl$getBounding.width,\n      height = _targetEl$getBounding.height;\n    posInfo.value = {\n      left: left,\n      top: top,\n      width: width,\n      height: height,\n      radius: 0\n    };\n  };\n  onMounted(function () {\n    watch([open, target], function () {\n      updatePosInfo();\n    }, {\n      immediate: true\n    });\n    window.addEventListener(\"resize\", updatePosInfo);\n  });\n  onBeforeUnmount(function () {\n    window.removeEventListener(\"resize\", updatePosInfo);\n  });\n  var getGapOffset = function getGapOffset(index) {\n    var _a;\n    return (_a = isArray(gap.value.offset) ? gap.value.offset[index] : gap.value.offset) != null ? _a : 6;\n  };\n  var mergedPosInfo = computed(function () {\n    var _a;\n    if (!posInfo.value) return posInfo.value;\n    var gapOffsetX = getGapOffset(0);\n    var gapOffsetY = getGapOffset(1);\n    var gapRadius = ((_a = gap.value) == null ? void 0 : _a.radius) || 2;\n    return {\n      left: posInfo.value.left - gapOffsetX,\n      top: posInfo.value.top - gapOffsetY,\n      width: posInfo.value.width + gapOffsetX * 2,\n      height: posInfo.value.height + gapOffsetY * 2,\n      radius: gapRadius\n    };\n  });\n  var triggerTarget = computed(function () {\n    var targetEl = getTargetEl();\n    if (!mergedMask.value || !targetEl || !window.DOMRect) {\n      return targetEl || void 0;\n    }\n    return {\n      getBoundingClientRect: function getBoundingClientRect() {\n        var _a, _b, _c, _d;\n        return window.DOMRect.fromRect({\n          width: ((_a = mergedPosInfo.value) == null ? void 0 : _a.width) || 0,\n          height: ((_b = mergedPosInfo.value) == null ? void 0 : _b.height) || 0,\n          x: ((_c = mergedPosInfo.value) == null ? void 0 : _c.left) || 0,\n          y: ((_d = mergedPosInfo.value) == null ? void 0 : _d.top) || 0\n        });\n      }\n    };\n  });\n  return {\n    mergedPosInfo: mergedPosInfo,\n    triggerTarget: triggerTarget\n  };\n};\nvar tourKey = Symbol(\"ElTour\");\nfunction isInViewPort(element) {\n  var viewWidth = window.innerWidth || document.documentElement.clientWidth;\n  var viewHeight = window.innerHeight || document.documentElement.clientHeight;\n  var _element$getBoundingC = element.getBoundingClientRect(),\n    top = _element$getBoundingC.top,\n    right = _element$getBoundingC.right,\n    bottom = _element$getBoundingC.bottom,\n    left = _element$getBoundingC.left;\n  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\n}\nvar useFloating = function useFloating(referenceRef, contentRef, arrowRef, placement, strategy, offset$1, zIndex, showArrow) {\n  var x = ref();\n  var y = ref();\n  var middlewareData = ref({});\n  var states = {\n    x: x,\n    y: y,\n    placement: placement,\n    strategy: strategy,\n    middlewareData: middlewareData\n  };\n  var middleware = computed(function () {\n    var _middleware = [offset(unref(offset$1)), flip(), shift(), overflowMiddleware()];\n    if (unref(showArrow) && unref(arrowRef)) {\n      _middleware.push(arrow({\n        element: unref(arrowRef)\n      }));\n    }\n    return _middleware;\n  });\n  var update = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var referenceEl, contentEl, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (isClient) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 2:\n            referenceEl = unref(referenceRef);\n            contentEl = unref(contentRef);\n            if (!(!referenceEl || !contentEl)) {\n              _context.next = 6;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 6:\n            _context.next = 8;\n            return computePosition(referenceEl, contentEl, {\n              placement: unref(placement),\n              strategy: unref(strategy),\n              middleware: unref(middleware)\n            });\n          case 8:\n            data = _context.sent;\n            keysOf(states).forEach(function (key) {\n              states[key].value = data[key];\n            });\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function update() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var contentStyle = computed(function () {\n    if (!unref(referenceRef)) {\n      return {\n        position: \"fixed\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate3d(-50%, -50%, 0)\",\n        maxWidth: \"100vw\",\n        zIndex: unref(zIndex)\n      };\n    }\n    var _unref = unref(middlewareData),\n      overflow = _unref.overflow;\n    return {\n      position: unref(strategy),\n      zIndex: unref(zIndex),\n      top: unref(y) != null ? \"\".concat(unref(y), \"px\") : \"\",\n      left: unref(x) != null ? \"\".concat(unref(x), \"px\") : \"\",\n      maxWidth: (overflow == null ? void 0 : overflow.maxWidth) ? \"\".concat(overflow == null ? void 0 : overflow.maxWidth, \"px\") : \"\"\n    };\n  });\n  var arrowStyle = computed(function () {\n    if (!unref(showArrow)) return {};\n    var _unref2 = unref(middlewareData),\n      arrow2 = _unref2.arrow;\n    return {\n      left: (arrow2 == null ? void 0 : arrow2.x) != null ? \"\".concat(arrow2 == null ? void 0 : arrow2.x, \"px\") : \"\",\n      top: (arrow2 == null ? void 0 : arrow2.y) != null ? \"\".concat(arrow2 == null ? void 0 : arrow2.y, \"px\") : \"\"\n    };\n  });\n  var cleanup;\n  onMounted(function () {\n    var referenceEl = unref(referenceRef);\n    var contentEl = unref(contentRef);\n    if (referenceEl && contentEl) {\n      cleanup = autoUpdate(referenceEl, contentEl, update);\n    }\n    watchEffect(function () {\n      update();\n    });\n  });\n  onBeforeUnmount(function () {\n    cleanup && cleanup();\n  });\n  return {\n    update: update,\n    contentStyle: contentStyle,\n    arrowStyle: arrowStyle\n  };\n};\nvar overflowMiddleware = function overflowMiddleware() {\n  return {\n    name: \"overflow\",\n    fn: function fn(state) {\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var overflow, overWidth, floatingWidth;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return detectOverflow(state);\n            case 2:\n              overflow = _context2.sent;\n              overWidth = 0;\n              if (overflow.left > 0) overWidth = overflow.left;\n              if (overflow.right > 0) overWidth = overflow.right;\n              floatingWidth = state.rects.floating.width;\n              return _context2.abrupt(\"return\", {\n                data: {\n                  maxWidth: floatingWidth - overWidth\n                }\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    }\n  };\n};\nexport { tourKey, useFloating, useTarget };","map":{"version":3,"names":["useTarget","target","open","gap","mergedMask","scrollIntoViewOptions","posInfo","ref","getTargetEl","targetEl","isString","value","document","querySelector","isFunction","updatePosInfo","isInViewPort","scrollIntoView","_targetEl$getBounding","getBoundingClientRect","left","top","width","height","radius","onMounted","watch","immediate","window","addEventListener","onBeforeUnmount","removeEventListener","getGapOffset","index","_a","isArray","offset","mergedPosInfo","computed","gapOffsetX","gapOffsetY","gapRadius","triggerTarget","DOMRect","_b","_c","_d","fromRect","x","y","tourKey","Symbol","element","viewWidth","innerWidth","documentElement","clientWidth","viewHeight","innerHeight","clientHeight","_element$getBoundingC","right","bottom","useFloating","referenceRef","contentRef","arrowRef","placement","strategy","offset$1","zIndex","showArrow","middlewareData","states","middleware","_middleware","unref","flip","shift","overflowMiddleware","push","arrow","update","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","referenceEl","contentEl","data","wrap","_callee$","_context","prev","next","isClient","abrupt","computePosition","sent","keysOf","forEach","key","stop","apply","arguments","contentStyle","position","transform","maxWidth","_unref","overflow","concat","arrowStyle","_unref2","arrow2","cleanup","autoUpdate","watchEffect","name","fn","state","_callee2","overWidth","floatingWidth","_callee2$","_context2","detectOverflow","rects","floating"],"sources":["../../../../../../packages/components/tour/src/helper.ts"],"sourcesContent":["import {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  unref,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  detectOverflow,\n  flip,\n  offset as offsetMiddelware,\n  shift,\n} from '@floating-ui/dom'\nimport {\n  isArray,\n  isClient,\n  isFunction,\n  isString,\n  keysOf,\n} from '@element-plus/utils'\n\nimport type {\n  CSSProperties,\n  Component,\n  InjectionKey,\n  Ref,\n  SetupContext,\n} from 'vue'\nimport type { UseNamespaceReturn } from '@element-plus/hooks'\nimport type { PosInfo, TourGap, TourMask } from './types'\nimport type {\n  ComputePositionReturn,\n  Middleware,\n  Placement,\n  Strategy,\n  VirtualElement,\n} from '@floating-ui/dom'\nimport type { TourStepProps } from './step'\n\nexport const useTarget = (\n  target: Ref<\n    string | HTMLElement | (() => HTMLElement | null) | null | undefined\n  >,\n  open: Ref<boolean>,\n  gap: Ref<TourGap>,\n  mergedMask: Ref<TourMask>,\n  scrollIntoViewOptions: Ref<boolean | ScrollIntoViewOptions>\n) => {\n  const posInfo: Ref<PosInfo | null> = ref(null)\n\n  const getTargetEl = () => {\n    let targetEl: HTMLElement | null | undefined\n    if (isString(target.value)) {\n      targetEl = document.querySelector<HTMLElement>(target.value)\n    } else if (isFunction(target.value)) {\n      targetEl = target.value()\n    } else {\n      targetEl = target.value\n    }\n    return targetEl\n  }\n\n  const updatePosInfo = () => {\n    const targetEl = getTargetEl()\n    if (!targetEl || !open.value) {\n      posInfo.value = null\n      return\n    }\n    if (!isInViewPort(targetEl)) {\n      targetEl.scrollIntoView(scrollIntoViewOptions.value)\n    }\n    const { left, top, width, height } = targetEl.getBoundingClientRect()\n    posInfo.value = {\n      left,\n      top,\n      width,\n      height,\n      radius: 0,\n    }\n  }\n\n  onMounted(() => {\n    watch(\n      [open, target],\n      () => {\n        updatePosInfo()\n      },\n      {\n        immediate: true,\n      }\n    )\n    window.addEventListener('resize', updatePosInfo)\n  })\n\n  onBeforeUnmount(() => {\n    window.removeEventListener('resize', updatePosInfo)\n  })\n\n  const getGapOffset = (index: number) =>\n    (isArray(gap.value.offset) ? gap.value.offset[index] : gap.value.offset) ??\n    6\n\n  const mergedPosInfo = computed(() => {\n    if (!posInfo.value) return posInfo.value\n\n    const gapOffsetX = getGapOffset(0)\n    const gapOffsetY = getGapOffset(1)\n    const gapRadius = gap.value?.radius || 2\n\n    return {\n      left: posInfo.value.left - gapOffsetX,\n      top: posInfo.value.top - gapOffsetY,\n      width: posInfo.value.width + gapOffsetX * 2,\n      height: posInfo.value.height + gapOffsetY * 2,\n      radius: gapRadius,\n    }\n  })\n\n  const triggerTarget = computed(() => {\n    const targetEl = getTargetEl()\n    if (!mergedMask.value || !targetEl || !window.DOMRect) {\n      return targetEl || undefined\n    }\n\n    return {\n      getBoundingClientRect() {\n        return window.DOMRect.fromRect({\n          width: mergedPosInfo.value?.width || 0,\n          height: mergedPosInfo.value?.height || 0,\n          x: mergedPosInfo.value?.left || 0,\n          y: mergedPosInfo.value?.top || 0,\n        })\n      },\n    }\n  })\n\n  return {\n    mergedPosInfo,\n    triggerTarget,\n  }\n}\n\nexport interface TourContext {\n  currentStep: Ref<TourStepProps | undefined>\n  current: Ref<number>\n  total: Ref<number>\n  showClose: Ref<boolean>\n  closeIcon: Ref<string | Component>\n  mergedType: Ref<'default' | 'primary' | undefined>\n  ns: UseNamespaceReturn\n  slots: SetupContext['slots']\n  updateModelValue(modelValue: boolean): void\n  onClose(): void\n  onFinish(): void\n  onChange(): void\n}\n\nexport const tourKey: InjectionKey<TourContext> = Symbol('ElTour')\n\nfunction isInViewPort(element: HTMLElement) {\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight\n  const { top, right, bottom, left } = element.getBoundingClientRect()\n\n  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight\n}\n\nexport const useFloating = (\n  referenceRef: Ref<HTMLElement | VirtualElement | null>,\n  contentRef: Ref<HTMLElement | null>,\n  arrowRef: Ref<HTMLElement | null>,\n  placement: Ref<Placement | undefined>,\n  strategy: Ref<Strategy>,\n  offset: Ref<number>,\n  zIndex: Ref<number>,\n  showArrow: Ref<boolean>\n) => {\n  const x = ref<number>()\n  const y = ref<number>()\n  const middlewareData = ref<ComputePositionReturn['middlewareData']>({})\n\n  const states = {\n    x,\n    y,\n    placement,\n    strategy,\n    middlewareData,\n  } as const\n\n  const middleware = computed(() => {\n    const _middleware: Middleware[] = [\n      offsetMiddelware(unref(offset)),\n      flip(),\n      shift(),\n      overflowMiddleware(),\n    ]\n\n    if (unref(showArrow) && unref(arrowRef)) {\n      _middleware.push(\n        arrow({\n          element: unref(arrowRef)!,\n        })\n      )\n    }\n    return _middleware\n  })\n\n  const update = async () => {\n    if (!isClient) return\n\n    const referenceEl = unref(referenceRef)\n    const contentEl = unref(contentRef)\n    if (!referenceEl || !contentEl) return\n\n    const data = await computePosition(referenceEl, contentEl, {\n      placement: unref(placement),\n      strategy: unref(strategy),\n      middleware: unref(middleware),\n    })\n\n    keysOf(states).forEach((key) => {\n      states[key].value = data[key]\n    })\n  }\n\n  const contentStyle = computed<CSSProperties>(() => {\n    if (!unref(referenceRef)) {\n      return {\n        position: 'fixed',\n        top: '50%',\n        left: '50%',\n        transform: 'translate3d(-50%, -50%, 0)',\n        maxWidth: '100vw',\n        zIndex: unref(zIndex),\n      }\n    }\n\n    const { overflow } = unref(middlewareData)\n\n    return {\n      position: unref(strategy),\n      zIndex: unref(zIndex),\n      top: unref(y) != null ? `${unref(y)}px` : '',\n      left: unref(x) != null ? `${unref(x)}px` : '',\n      maxWidth: overflow?.maxWidth ? `${overflow?.maxWidth}px` : '',\n    }\n  })\n\n  const arrowStyle = computed<CSSProperties>(() => {\n    if (!unref(showArrow)) return {}\n\n    const { arrow } = unref(middlewareData)\n    return {\n      left: arrow?.x != null ? `${arrow?.x}px` : '',\n      top: arrow?.y != null ? `${arrow?.y}px` : '',\n    }\n  })\n\n  let cleanup: any\n  onMounted(() => {\n    const referenceEl = unref(referenceRef)\n    const contentEl = unref(contentRef)\n    if (referenceEl && contentEl) {\n      cleanup = autoUpdate(referenceEl, contentEl, update)\n    }\n\n    watchEffect(() => {\n      update()\n    })\n  })\n\n  onBeforeUnmount(() => {\n    cleanup && cleanup()\n  })\n\n  return {\n    update,\n    contentStyle,\n    arrowStyle,\n  }\n}\n\nconst overflowMiddleware = (): Middleware => {\n  return {\n    name: 'overflow',\n    async fn(state) {\n      const overflow = await detectOverflow(state)\n      let overWidth = 0\n      if (overflow.left > 0) overWidth = overflow.left\n      if (overflow.right > 0) overWidth = overflow.right\n      const floatingWidth = state.rects.floating.width\n      return {\n        data: {\n          maxWidth: floatingWidth - overWidth,\n        },\n      }\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}