{"ast":null,"code":"function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { defineComponent, computed, shallowRef, ref, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeStyle, renderSlot } from 'vue';\nimport { useMutationObserver } from '@vueuse/core';\nimport { watermarkProps } from './watermark.mjs';\nimport { reRendering, getStyleStr, getPixelRatio } from './utils.mjs';\nimport useClips, { FontGap } from './useClips.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isArray } from '@vue/shared';\nimport { isUndefined } from '../../../utils/types.mjs';\nvar __default__ = defineComponent({\n  name: \"ElWatermark\"\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: watermarkProps,\n  setup: function setup(__props) {\n    var props = __props;\n    var style = {\n      position: \"relative\"\n    };\n    var color = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.color) != null ? _b : \"rgba(0,0,0,.15)\";\n    });\n    var fontSize = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontSize) != null ? _b : 16;\n    });\n    var fontWeight = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontWeight) != null ? _b : \"normal\";\n    });\n    var fontStyle = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontStyle) != null ? _b : \"normal\";\n    });\n    var fontFamily = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontFamily) != null ? _b : \"sans-serif\";\n    });\n    var textAlign = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textAlign) != null ? _b : \"center\";\n    });\n    var textBaseline = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textBaseline) != null ? _b : \"hanging\";\n    });\n    var gapX = computed(function () {\n      return props.gap[0];\n    });\n    var gapY = computed(function () {\n      return props.gap[1];\n    });\n    var gapXCenter = computed(function () {\n      return gapX.value / 2;\n    });\n    var gapYCenter = computed(function () {\n      return gapY.value / 2;\n    });\n    var offsetLeft = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : gapXCenter.value;\n    });\n    var offsetTop = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[1]) != null ? _b : gapYCenter.value;\n    });\n    var getMarkStyle = function getMarkStyle() {\n      var markStyle = {\n        zIndex: props.zIndex,\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        backgroundRepeat: \"repeat\"\n      };\n      var positionLeft = offsetLeft.value - gapXCenter.value;\n      var positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = \"\".concat(positionLeft, \"px\");\n        markStyle.width = \"calc(100% - \".concat(positionLeft, \"px)\");\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = \"\".concat(positionTop, \"px\");\n        markStyle.height = \"calc(100% - \".concat(positionTop, \"px)\");\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = \"\".concat(positionLeft, \"px \").concat(positionTop, \"px\");\n      return markStyle;\n    };\n    var containerRef = shallowRef(null);\n    var watermarkRef = shallowRef();\n    var stopObservation = ref(false);\n    var destroyWatermark = function destroyWatermark() {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = void 0;\n      }\n    };\n    var appendWatermark = function appendWatermark(base64Url, markWidth) {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute(\"style\", getStyleStr(_objectSpread(_objectSpread({}, getMarkStyle()), {}, {\n          backgroundImage: \"url('\".concat(base64Url, \"')\"),\n          backgroundSize: \"\".concat(Math.floor(markWidth), \"px\")\n        })));\n        (_a = containerRef.value) == null ? void 0 : _a.append(watermarkRef.value);\n        setTimeout(function () {\n          stopObservation.value = false;\n        });\n      }\n    };\n    var getMarkSize = function getMarkSize(ctx) {\n      var defaultWidth = 120;\n      var defaultHeight = 64;\n      var image = props.image,\n        content = props.content,\n        width = props.width,\n        height = props.height,\n        rotate = props.rotate;\n      if (!image && ctx.measureText) {\n        ctx.font = \"\".concat(Number(fontSize.value), \"px \").concat(fontFamily.value);\n        var contents = isArray(content) ? content : [content];\n        var maxWidth = 0;\n        var maxHeight = 0;\n        contents.forEach(function (item) {\n          var _ctx$measureText = ctx.measureText(item),\n            width2 = _ctx$measureText.width,\n            fontBoundingBoxAscent = _ctx$measureText.fontBoundingBoxAscent,\n            fontBoundingBoxDescent = _ctx$measureText.fontBoundingBoxDescent,\n            actualBoundingBoxAscent = _ctx$measureText.actualBoundingBoxAscent,\n            actualBoundingBoxDescent = _ctx$measureText.actualBoundingBoxDescent;\n          var height2 = isUndefined(fontBoundingBoxAscent) ? actualBoundingBoxAscent + actualBoundingBoxDescent : fontBoundingBoxAscent + fontBoundingBoxDescent;\n          if (width2 > maxWidth) maxWidth = Math.ceil(width2);\n          if (height2 > maxHeight) maxHeight = Math.ceil(height2);\n        });\n        defaultWidth = maxWidth;\n        defaultHeight = maxHeight * contents.length + (contents.length - 1) * FontGap;\n        var angle = Math.PI / 180 * Number(rotate);\n        var space = Math.ceil(Math.abs(Math.sin(angle) * defaultHeight) / 2);\n        defaultWidth += space;\n      }\n      return [width != null ? width : defaultWidth, height != null ? height : defaultHeight];\n    };\n    var getClips = useClips();\n    var renderWatermark = function renderWatermark() {\n      var canvas = document.createElement(\"canvas\");\n      var ctx = canvas.getContext(\"2d\");\n      var image = props.image;\n      var content = props.content;\n      var rotate = props.rotate;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement(\"div\");\n        }\n        var ratio = getPixelRatio();\n        var _getMarkSize = getMarkSize(ctx),\n          _getMarkSize2 = _slicedToArray(_getMarkSize, 2),\n          markWidth = _getMarkSize2[0],\n          markHeight = _getMarkSize2[1];\n        var drawCanvas = function drawCanvas(drawContent) {\n          var _getClips = getClips(drawContent || \"\", rotate, ratio, markWidth, markHeight, {\n              color: color.value,\n              fontSize: fontSize.value,\n              fontStyle: fontStyle.value,\n              fontWeight: fontWeight.value,\n              fontFamily: fontFamily.value,\n              textAlign: textAlign.value,\n              textBaseline: textBaseline.value\n            }, gapX.value, gapY.value),\n            _getClips2 = _slicedToArray(_getClips, 2),\n            textClips = _getClips2[0],\n            clipWidth = _getClips2[1];\n          appendWatermark(textClips, clipWidth);\n        };\n        if (image) {\n          var img = new Image();\n          img.onload = function () {\n            drawCanvas(img);\n          };\n          img.onerror = function () {\n            drawCanvas(content);\n          };\n          img.crossOrigin = \"anonymous\";\n          img.referrerPolicy = \"no-referrer\";\n          img.src = image;\n        } else {\n          drawCanvas(content);\n        }\n      }\n    };\n    onMounted(function () {\n      renderWatermark();\n    });\n    watch(function () {\n      return props;\n    }, function () {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: \"post\"\n    });\n    onBeforeUnmount(function () {\n      destroyWatermark();\n    });\n    var onMutate = function onMutate(mutations) {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(function (mutation) {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true,\n      subtree: true,\n      childList: true\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"containerRef\",\n        ref: containerRef,\n        style: normalizeStyle([style])\n      }, [renderSlot(_ctx.$slots, \"default\")], 4);\n    };\n  }\n}));\nvar Watermark = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"watermark.vue\"]]);\nexport { Watermark as default };","map":{"version":3,"names":["name","style","position","color","computed","_a","_b","props","font","fontSize","fontWeight","fontStyle","fontFamily","textAlign","textBaseline","gapX","gap","gapY","gapXCenter","value","gapYCenter","offsetLeft","offset","offsetTop","getMarkStyle","markStyle","zIndex","left","top","width","height","pointerEvents","backgroundRepeat","positionLeft","positionTop","concat","backgroundPosition","containerRef","shallowRef","watermarkRef","stopObservation","ref","destroyWatermark","remove","appendWatermark","base64Url","markWidth","setAttribute","getStyleStr","_objectSpread","backgroundImage","backgroundSize","Math","floor","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","image","content","rotate","measureText","Number","contents","isArray","maxWidth","maxHeight","forEach","item","_ctx$measureText","width2","fontBoundingBoxAscent","fontBoundingBoxDescent","actualBoundingBoxAscent","actualBoundingBoxDescent","height2","isUndefined","ceil","length","FontGap","angle","PI","space","abs","sin","getClips","useClips","renderWatermark","canvas","document","createElement","getContext","ratio","getPixelRatio","_getMarkSize","_getMarkSize2","_slicedToArray","markHeight","drawCanvas","drawContent","_getClips","_getClips2","textClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","onMounted","watch","deep","flush","onBeforeUnmount","onMutate","mutations"],"sources":["../../../../../../packages/components/watermark/src/watermark.vue"],"sourcesContent":["<template>\n  <div ref=\"containerRef\" :style=\"[style]\">\n    <slot />\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useMutationObserver } from '@vueuse/core'\nimport { isArray, isUndefined } from '@element-plus/utils'\nimport { watermarkProps } from './watermark'\nimport { getPixelRatio, getStyleStr, reRendering } from './utils'\nimport useClips, { FontGap } from './useClips'\nimport type { WatermarkProps } from './watermark'\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElWatermark',\n})\n\nconst style: CSSProperties = {\n  position: 'relative',\n}\n\nconst props = defineProps(watermarkProps)\nconst color = computed(() => props.font?.color ?? 'rgba(0,0,0,.15)')\nconst fontSize = computed(() => props.font?.fontSize ?? 16)\nconst fontWeight = computed(() => props.font?.fontWeight ?? 'normal')\nconst fontStyle = computed(() => props.font?.fontStyle ?? 'normal')\nconst fontFamily = computed(() => props.font?.fontFamily ?? 'sans-serif')\nconst textAlign = computed(() => props.font?.textAlign ?? 'center')\nconst textBaseline = computed(() => props.font?.textBaseline ?? 'hanging')\n\nconst gapX = computed(() => props.gap[0])\nconst gapY = computed(() => props.gap[1])\nconst gapXCenter = computed(() => gapX.value / 2)\nconst gapYCenter = computed(() => gapY.value / 2)\nconst offsetLeft = computed(() => props.offset?.[0] ?? gapXCenter.value)\nconst offsetTop = computed(() => props.offset?.[1] ?? gapYCenter.value)\n\nconst getMarkStyle = () => {\n  const markStyle: CSSProperties = {\n    zIndex: props.zIndex,\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none',\n    backgroundRepeat: 'repeat',\n  }\n\n  /** Calculate the style of the offset */\n  let positionLeft = offsetLeft.value - gapXCenter.value\n  let positionTop = offsetTop.value - gapYCenter.value\n  if (positionLeft > 0) {\n    markStyle.left = `${positionLeft}px`\n    markStyle.width = `calc(100% - ${positionLeft}px)`\n    positionLeft = 0\n  }\n  if (positionTop > 0) {\n    markStyle.top = `${positionTop}px`\n    markStyle.height = `calc(100% - ${positionTop}px)`\n    positionTop = 0\n  }\n  markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`\n\n  return markStyle\n}\n\nconst containerRef = shallowRef<HTMLDivElement | null>(null)\nconst watermarkRef = shallowRef<HTMLDivElement>()\nconst stopObservation = ref(false)\n\nconst destroyWatermark = () => {\n  if (watermarkRef.value) {\n    watermarkRef.value.remove()\n    watermarkRef.value = undefined\n  }\n}\nconst appendWatermark = (base64Url: string, markWidth: number) => {\n  if (containerRef.value && watermarkRef.value) {\n    stopObservation.value = true\n    watermarkRef.value.setAttribute(\n      'style',\n      getStyleStr({\n        ...getMarkStyle(),\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${Math.floor(markWidth)}px`,\n      })\n    )\n    containerRef.value?.append(watermarkRef.value)\n    // Delayed execution\n    setTimeout(() => {\n      stopObservation.value = false\n    })\n  }\n}\n\n/**\n * Get the width and height of the watermark. The default values are as follows\n * Image: [120, 64]; Content: It's calculated by content;\n */\nconst getMarkSize = (ctx: CanvasRenderingContext2D) => {\n  let defaultWidth = 120\n  let defaultHeight = 64\n\n  const { image, content, width, height, rotate } = props\n\n  if (!image && ctx.measureText) {\n    ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`\n\n    const contents = isArray(content) ? content : [content]\n    let maxWidth = 0\n    let maxHeight = 0\n\n    contents.forEach((item) => {\n      const {\n        width,\n        fontBoundingBoxAscent,\n        fontBoundingBoxDescent,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n      } = ctx.measureText(item!)\n      // Using `actualBoundingBoxAscent` to be compatible with lower version browsers (eg: Firefox < 116)\n      const height = isUndefined(fontBoundingBoxAscent)\n        ? actualBoundingBoxAscent + actualBoundingBoxDescent\n        : fontBoundingBoxAscent + fontBoundingBoxDescent\n\n      if (width > maxWidth) maxWidth = Math.ceil(width)\n      if (height > maxHeight) maxHeight = Math.ceil(height)\n    })\n\n    defaultWidth = maxWidth\n    defaultHeight =\n      maxHeight * contents.length + (contents.length - 1) * FontGap\n\n    const angle = (Math.PI / 180) * Number(rotate)\n    const space = Math.ceil(Math.abs(Math.sin(angle) * defaultHeight) / 2)\n\n    defaultWidth += space\n  }\n\n  return [width ?? defaultWidth, height ?? defaultHeight] as const\n}\n\nconst getClips = useClips()\n\nconst renderWatermark = () => {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  const image = props.image\n  const content = props.content\n  const rotate = props.rotate\n\n  if (ctx) {\n    if (!watermarkRef.value) {\n      watermarkRef.value = document.createElement('div')\n    }\n\n    const ratio = getPixelRatio()\n    const [markWidth, markHeight] = getMarkSize(ctx)\n\n    const drawCanvas = (\n      drawContent?: NonNullable<WatermarkProps['content']> | HTMLImageElement\n    ) => {\n      const [textClips, clipWidth] = getClips(\n        drawContent || '',\n        rotate,\n        ratio,\n        markWidth,\n        markHeight,\n        {\n          color: color.value,\n          fontSize: fontSize.value,\n          fontStyle: fontStyle.value,\n          fontWeight: fontWeight.value,\n          fontFamily: fontFamily.value,\n          textAlign: textAlign.value,\n          textBaseline: textBaseline.value,\n        },\n        gapX.value,\n        gapY.value\n      )\n\n      appendWatermark(textClips, clipWidth)\n    }\n\n    if (image) {\n      const img = new Image()\n      img.onload = () => {\n        drawCanvas(img)\n      }\n      img.onerror = () => {\n        drawCanvas(content)\n      }\n      img.crossOrigin = 'anonymous'\n      img.referrerPolicy = 'no-referrer'\n      img.src = image\n    } else {\n      drawCanvas(content)\n    }\n  }\n}\n\nonMounted(() => {\n  renderWatermark()\n})\n\nwatch(\n  () => props,\n  () => {\n    renderWatermark()\n  },\n  {\n    deep: true,\n    flush: 'post',\n  }\n)\n\nonBeforeUnmount(() => {\n  destroyWatermark()\n})\n\nconst onMutate = (mutations: MutationRecord[]) => {\n  if (stopObservation.value) {\n    return\n  }\n  mutations.forEach((mutation) => {\n    if (reRendering(mutation, watermarkRef.value)) {\n      destroyWatermark()\n      renderWatermark()\n    }\n  })\n}\n\nuseMutationObserver(containerRef, onMutate, {\n  attributes: true,\n  subtree: true,\n  childList: true,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}